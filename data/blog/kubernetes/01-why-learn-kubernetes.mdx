---
title: '[Kubernetes 筆記] 為什麼要學 Kubernetes？'
date: '2025-09-11'
tags: ['Kubernetes', 'DevOps', 'Cloud']
draft: false
summary: 'Kubernetes 是目前最主流的容器編排平台，解決了傳統伺服器與容器管理上的痛點。本文整理學習 Kubernetes 前需要理解的背景與核心價值。'
---

## 為什麼需要 Kubernetes？

在深入探討 **Kubernetes（K8s）**之前，我們必須先了解它所解決的核心問題：如何有效地管理應用程式容器。要理解這一點，我們得從**容器化**本身的好處說起。

## 容器化（Containerize）的優勢

在過去，Developer 常遇到一個普遍的問題：「在我的電腦上明明能跑，為什麼到了伺服器上就不行？」這通常是**環境差異**造成的。

傳統部署方式中，Application 需要依賴特定的 OS, Library 和 Config，這些依賴性在不同環境中很容易出錯。

容器（Container），例如：**Docker**，就是為了解決這個問題而誕生的。你可以把容器想像成一個獨立、輕量級的虛擬環境，它將 Application 及其所有依賴項（Code, Library, Config file...等）打包在一起。

這樣做有三個主要優勢：

1. **環境一致性**：不管容器在哪個環境中執行，都能確保應用程式的執行結果一致。
2. **隔離性**：每個容器都是獨立的，互不干擾，一個容器的問題不會影響到其他容器。
3. **輕量且快速**：相比傳統虛擬機，容器啟動速度更快，佔用資源更少，可以更有效地利用伺服器資源。

有了容器，我們就能輕鬆地在 dev, staging, production 中跑應用程式，解決了因為環境的問題，造成程式不能跑的痛點。

## 單個容器的挑戰：從容器到「容器群（Cotainer cluster）」

容器化（Containerize）解決了 single application 部署的痛點，但在實際的 production 環境中，我們還會面臨更多挑戰。當你的網站或服務流量激增，單一容器可能無法應付需求；如果你的 server 發生故障，所有容器都會隨之 crash，服務將無法使用。

這些是單個容器無法解決的問題：

- **擴展性（Scalability）**：當流量增加時，如何自動增加容器數量來分散負載？流量減少時，又如何自動縮減（Auto scale）以節省資源？
- **高可用性（High Availability）**：如果某個容器或伺服器故障，如何確保服務不會中斷，並自動重新啟動失敗的容器？
- **負載平衡（Load Balancing）**：在多個容器同時執行時，如何將用戶請求平均地分配到每個容器上？
- **自動化部署與更新**：每次應用程式更新，如何安全、無縫地用新版本替換舊版本，同時避免服務中斷？
- **服務發現與網路**：在動態變化的環境中，容器如何找到並與其他容器通訊？

這些問題若透過手動方式來管理，不僅效率低下，還容易出錯。這時，我們需要一個「容器編排」工具，來自動化和管理這些複雜的任務。

## Kubernetes 的登場

Kubernetes，簡稱 K8s，就是最受歡迎的**容器編排工具（Container orchestration tool）**。你可以將它想像成一個智慧的自動化總指揮官。它不只負責讓容器執行，還能管理它們的整個 life cycle，從部署、擴展、更新到故障排除。

K8s 解決了上述所有問題，它能：

- **自動擴展和縮減（Automatic Scaling）**： 根據 CPU usage 或其他 metrics，自動調整容器數量。
- **自我修復（Self-Healing）**：如果某個容器 crash，K8s 會自動偵測並重新啟動它。
- **負載平衡（Load Balancing）**：K8s 內建了負載平衡機制，可以將流量導向健康的容器。
- **自動化部署（Automated Deployment）**：你可以宣告式地描述期望的狀態，K8s 會自動達成目標，並提供無縫的版本更新和回滾能力。

## 小結

簡而言之，**容器化解決了應用程式打包和環境一致性的問題，而 Kubernetes 則解決了在生產環境中管理這些容器的複雜性。**

這就是為什麼 Kubernetes 成為現代雲原生應用程式開發不可或缺的基石。
